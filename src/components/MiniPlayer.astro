---
// src/components/MiniPlayer.astro
// Persisted player component that listens for 'play-episode' events
import FloatingBar from './player/FloatingBar.astro';
import ImmersiveView from './player/ImmersiveView.astro';
import './player/SharedPlayerStyles.css';
---

<!-- Mini Player (Floating) Components -->
<FloatingBar />
<ImmersiveView />

<!-- Hidden Logic / Controller -->
<script>
    import { FastAverageColor } from 'fast-average-color';
    // @ts-ignore

    declare global {
        interface Window {
            hasGlobalPlayerListener: boolean;
            playerCurrentUrl: string | null;
            playerMeta: { title: string, image: string, author: string } | null;
            visualizerInterval: number;
        }
    }

    // We use a global flag to prevent attaching GLOBAL event listeners (like 'play-episode' on document) multiple times.
    // However, 'astro:page-load' needs to be handled carefully.

        window.playerCurrentUrl = null;
        window.playerMeta = null;
        
        // Modules are cached, so these run once.
        const fac = new FastAverageColor();



        // ---- Ambient Mode Logic ----
        const updateAmbientTheme = async (imageUrl: string) => {
            try {
                const color = await fac.getColorAsync(imageUrl);
                document.documentElement.style.setProperty('--color-primary-glow', color.rgba);
                // Also update the glow in immersive mode
                const glow = document.querySelector('.background-glow') as HTMLElement;
                if (glow) {
                    glow.style.background = `radial-gradient(circle at center, ${color.rgba}, transparent 70%)`;
                }
            } catch (e) {
                console.log("Ambient color failed", e);
            }
        };

        const setupCustomPlayer = (container: HTMLElement, url: string, title: string, cover: string, author: string, transcription: any[] | null = null) => {
             // 1. Inject HTML
             container.innerHTML = `
<div class="custom-audio-player">
  <div class="player-card" id="customPlayerCard">
    <div class="visualizer-container">
      <canvas id="audioVisualizer" width="300" height="100"></canvas>
    </div>
    <div class="cover-image">
      ${cover ? `<img src="${cover}" alt="${title}" />` : `
        <div class="cover-placeholder">
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" d="M9 9l10.5-3m0 6.553v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 11-.99-3.467l2.31-.66a2.25 2.25 0 001.632-2.163zm0 0V2.25L9 5.25v10.303m0 0v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 11-.99-3.467l2.31-.66a2.25 2.25 0 001.632-2.163z" />
          </svg>
        </div>
      `}
    </div>

    <div class="player-content">
      <div class="track-info">
        <h2>${title}</h2>
        <p>${author}</p>
      </div>

      <div class="progress-section">
        <input type="range" id="seekBar" value="0" step="0.1" />
      </div>
    </div>
    
    <div class="controls-row">
        <div class="main-controls">
           <button id="backwardBtn" class="secondary-control" aria-label="Retroceder 15s">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 15l-6 6m0 0l-6-6m6 6V9a6 6 0 0112 0v3" />
            </svg>
          </button>

          <button id="playPauseBtn" class="play-pause-btn" aria-label="Reproducir/Pausar">
            <svg id="iconPlay" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
              <path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393" />
            </svg>
            <svg id="iconPause" class="hidden icon-pause" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
              <path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5m5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.A 1.5 0 0 1 10.5 3.5" />
            </svg>
            <svg id="iconLoading" class="hidden spinner" viewBox="0 0 50 50">
              <circle class="path" cx="25" cy="25" r="20" fill="none" stroke-width="5"></circle>
            </svg>
          </button>
          
           <button id="forwardBtn" class="secondary-control" aria-label="Avanzar 15s">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 15l6 6m0 0l6-6m-6 6V9a6 6 0 00-12 0v3" />
            </svg>
          </button>
        </div>

        <div class="volume-controls">
           <button id="speedBtn" class="speed-btn">1x</button>
           <div class="volume-slider-container">
             <input type="range" id="volumeBar" min="0" max="1" step="0.05" value="1" />
           </div>
           <button id="maximizeBtn" class="secondary-control" aria-label="Pantalla completa" style="margin-left: 4px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"/></svg>
           </button>
        </div>
    </div>
  </div>
   <audio id="audioElement" src="${url}" preload="metadata" crossorigin="anonymous"></audio>
</div>
             `;

             // 2. Attach Logic (Simplified from audioPlayer.ts)
             const audio = container.querySelector('#audioElement') as HTMLAudioElement;
             const playBtn = container.querySelector('#playPauseBtn') as HTMLElement;
             const backBtn = container.querySelector('#backwardBtn') as HTMLElement;
             const fwdBtn = container.querySelector('#forwardBtn') as HTMLElement;
             const seekBar = container.querySelector('#seekBar') as HTMLInputElement;
             const volumeBar = container.querySelector('#volumeBar') as HTMLInputElement;
             const speedBtn = container.querySelector('#speedBtn') as HTMLElement;
             
             const iconPlay = container.querySelector('#iconPlay');
             const iconPause = container.querySelector('#iconPause');
             const iconLoading = container.querySelector('#iconLoading');
             
             const speeds = [1, 1.25, 1.5, 2, 0.75];
             let speedIdx = 0;

             // State updates
             const updateIcons = () => {
                 if(iconLoading && !iconLoading.classList.contains('hidden')) return;
                 if(audio.paused) {
                     iconPlay?.classList.remove('hidden');
                     iconPause?.classList.add('hidden');
                 } else {
                     iconPlay?.classList.add('hidden');
                     iconPause?.classList.remove('hidden');
                 }
             };

             // Listeners
             playBtn.onclick = () => {
                 if(audio.paused) audio.play();
                 else audio.pause();
             };
             
             backBtn.onclick = () => audio.currentTime = Math.max(0, audio.currentTime - 15);
             fwdBtn.onclick = () => audio.currentTime = Math.min(audio.duration, audio.currentTime + 15);
             
             seekBar.oninput = () => {
                 audio.currentTime = parseFloat(seekBar.value);
             }
             
             const updateSeek = () => {
                  if(document.activeElement !== seekBar) {
                      seekBar.value = audio.currentTime.toString();
                  }
                  // Visualizer Draw call loop is separate
             };

             volumeBar.oninput = () => {
                 audio.volume = parseFloat(volumeBar.value);
             }
             
             
             speedBtn.onclick = () => {
                 speedIdx = (speedIdx + 1) % speeds.length;
                 const s = speeds[speedIdx];
                 audio.playbackRate = s;
                 speedBtn.innerText = `${s}x`;
             }

             // Maximize
             const maxBtn = container.querySelector('#maximizeBtn') as HTMLElement;
             if(maxBtn) {
                 maxBtn.onclick = () => {
                     const immersive = document.getElementById('immersive-player');
                     if (immersive) immersive.classList.remove('hidden');
                 };
             }

             // Audio events
             audio.ontimeupdate = updateSeek;
             
             audio.onloadedmetadata = () => {
                 seekBar.max = audio.duration.toString();
                 iconLoading?.classList.add('hidden');
                 updateIcons();
             };
             
             audio.onwaiting = () => {
                 iconPlay?.classList.add('hidden');
                 iconPause?.classList.add('hidden');
                 iconLoading?.classList.remove('hidden');
             };
             
             audio.onplaying = () => {
                 iconLoading?.classList.add('hidden');
                 updateIcons();
                 initVisualizer(); 
             };
             
             audio.onplay = updateIcons;
             audio.onpause = updateIcons;
             
             // Error Handling & CORS Fallback
             audio.onerror = (e) => {
                 const error = audio.error;
                 console.warn("Audio Error:", error);
                 if (error && (error.code === MediaError.MEDIA_ERR_NETWORK || error.code === MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED)) {
                     if (audio.hasAttribute("crossorigin")) {
                         console.info("CORS or Network error detected. Falling back to standard playback without Visualizer.");
                         // Remove crossorigin to allow opaque response (no visualizer, but plays)
                         audio.removeAttribute("crossorigin");
                         audio.load();
                         // The visualizer will fail gracefully in initVisualizer
                         if(playBtn) playBtn.click(); // Auto-resume if it was trying to play
                     }
                 }
             };
             
             // Visualizer (Simple version)
             let audioCtx: AudioContext;
             let analyser: AnalyserNode;
             let source: MediaElementAudioSourceNode;
             let canvas = container.querySelector('#audioVisualizer') as HTMLCanvasElement;
             
             const initVisualizer = () => {
                 // Check if we are allowed to visualize (CORS)
                 if (!audio.crossOrigin) return;

                 if(!audioCtx) {
                      const AudioContext = window.AudioContext || (window as any).webkitAudioContext;
                      audioCtx = new AudioContext();
                      try {
                          source = audioCtx.createMediaElementSource(audio);
                          analyser = audioCtx.createAnalyser();
                          analyser.fftSize = 64;
                          source.connect(analyser);
                          analyser.connect(audioCtx.destination);
                          draw();
                      } catch(e) {
                          console.log("Audio Context Error (likely CORS):", e);
                      }
                 } else if (audioCtx.state === 'suspended') {
                     audioCtx.resume();
                 }
             };
             
             const draw = () => {
                 if(!canvas || !analyser) return;
                 const ctx = canvas.getContext('2d');
                 if(!ctx) return;
                 const bufferLength = analyser.frequencyBinCount;
                 const dataArray = new Uint8Array(bufferLength);
                 
                 const renderFrame = () => {
                     if(audio.paused) return; // Stop drawing to save resources
                     requestAnimationFrame(renderFrame);
                     ctx.clearRect(0,0, canvas.width, canvas.height);
                     
                     if (!analyser) return; // Safeguard if CORS/AudioCtx failed
                     try {
                        analyser.getByteFrequencyData(dataArray);
                     } catch(e) { return ; }

                     const barWidth = (canvas.width / bufferLength) * 2;
                     let x = 0;
                     ctx.fillStyle = 'rgba(255,255,255,0.3)';
                     

                     // --- Immersive Drawing ---
                     const immCanvas = document.getElementById('audio-visualizer') as HTMLCanvasElement;
                     const immCtx = immCanvas ? immCanvas.getContext('2d') : null;
                     const immersiveOverlay = document.getElementById('immersive-player');
                     
                     if (immersiveOverlay && !immersiveOverlay.classList.contains('hidden') && immCanvas && immCtx) {
                          // Ensure size matches
                          if(immCanvas.width !== immCanvas.offsetWidth) {
                               immCanvas.width = immCanvas.offsetWidth;
                               immCanvas.height = immCanvas.offsetHeight;
                          }
                          
                          immCtx.clearRect(0, 0, immCanvas.width, immCanvas.height);
                          const bars = 64; // Use first 64 bins (bass/mid heavy) of the 256 or so
                          const step = Math.floor(bufferLength / bars);
                          const width = immCanvas.width / bars;
                          
                          immCtx.fillStyle = 'white';
                          
                          for(let i=0; i<bars; i++) {
                               // Average out a chunk for smoother bars
                               let sum = 0;
                               for(let j=0; j<step; j++) {
                                   sum += dataArray[i*step + j];
                               }
                               const val = sum / step;
                               
                               // Mirror effect for "wave"
                               // Center is immCanvas.height / 2
                               const h = (val / 255) * (immCanvas.height / 2); 
                               
                               const x = i * width;
                               const cy = immCanvas.height / 2;
                               
                               // Draw symmetric bar
                               // opacity based on height
                               immCtx.globalAlpha = Math.max(0.2, val / 255);
                               immCtx.fillRect(x + 2, cy - h, width - 4, h * 2); 
                          }
                          immCtx.globalAlpha = 1;
                     }
                 };
                 renderFrame();
             };
             
             // Apply dynamic background
             if(cover) {
                 fac.getColorAsync(cover).then(color => {
                     const card = container.querySelector('#customPlayerCard') as HTMLElement;
                     if(card) {
                         // Use a nice gradient mixing the extracted color
                         card.style.background = `linear-gradient(145deg, ${color.rgba} 0%, rgba(15, 23, 42, 0.95) 100%)`;
                     }
                 }).catch(e => console.log(e));
             }

             // --- Initialize Immersive Sync ---
             const immTitle = document.getElementById('immersive-title');
             const immAuthor = document.getElementById('immersive-author');
             const immCover = document.getElementById('immersive-cover') as HTMLImageElement;
             const immPlayBtn = document.getElementById('imm-play-btn');
             const immIconPlay = document.getElementById('imm-icon-play');
             const immIconPause = document.getElementById('imm-icon-pause');
             const immSeekBar = document.getElementById('imm-seek-bar') as HTMLInputElement;
             const immCurrentTime = document.getElementById('imm-current-time');
             const immDuration = document.getElementById('imm-duration');
             const immBack = document.getElementById('imm-back-btn');
             const immFwd = document.getElementById('imm-fwd-btn');

             if(immTitle) immTitle.innerText = title;
             if(immAuthor) immAuthor.innerText = author;
             if(immCover) immCover.src = cover || '/logo.png';
             if(cover) updateAmbientTheme(cover);

             // Sync Listeners
             if(immPlayBtn) {
                 immPlayBtn.onclick = () => {
                     if(audio.paused) audio.play();
                     else audio.pause();
                 };
             }
             if(immBack) immBack.onclick = () => audio.currentTime = Math.max(0, audio.currentTime - 15);
             if(immFwd) immFwd.onclick = () => audio.currentTime = Math.min(audio.duration, audio.currentTime + 15);
             
             // Toggle Lyrics
             const toggleLyricsBtn = document.getElementById('toggle-lyrics');
             const lyricsWrapper = document.getElementById('immersive-lyrics');
             const lyricsContainer = lyricsWrapper ? lyricsWrapper.querySelector('.lyrics-trackable') as HTMLElement : null;
             
             if(toggleLyricsBtn && lyricsWrapper) {
                 toggleLyricsBtn.onclick = () => {
                     lyricsWrapper.classList.toggle('hidden');
                     
                     // If we are showing lyrics and have transcription, ensure active line is computed
                     if(!lyricsWrapper.classList.contains('hidden') && transcription) {
                         // trigger update
                     }
                 };
             }
             
             // --- GLOBAL SEEK EVENT LISTENER (Cleanup old one if exists?) ---
             // Ideally we should manage listeners but for this case, we can assume one player active.
             document.addEventListener('veredillas:audio-seek', (e: Event) => {
                 const customEvent = e as CustomEvent;
                 if (customEvent.detail && typeof customEvent.detail.time === 'number') {
                     audio.currentTime = customEvent.detail.time;
                     if(audio.paused) audio.play();
                 }
             });

             // Render Lyrics
             let lyricLines: { time: number, el: HTMLElement }[] = [];
             
             if (transcription && lyricsContainer) {
                 lyricsContainer.innerHTML = ''; // Clear placeholder
                 const parseTime = (t: string) => {
                    const p = t.split(':').map(Number);
                    if(p.length === 2) return p[0]*60 + p[1];
                    if(p.length === 3) return p[0]*3600 + p[1]*60 + p[2];
                    return 0;
                 };

                 transcription.forEach((item, idx) => {
                     const p = document.createElement('p');
                     p.className = 'lyric-line';
                     p.innerText = item.text;
                     const seconds = parseTime(item.time);
                     p.onclick = () => audio.currentTime = seconds;
                     lyricsContainer.appendChild(p);
                     lyricLines.push({ time: seconds, el: p });
                 });
                 
                 // Add dummy end line
                 lyricLines.push({ time: 999999, el: document.createElement('div') });
             } else if (lyricsContainer) {
                 lyricsContainer.innerHTML = '<p class="lyrics-placeholder" style="color:rgba(255,255,255,0.5); text-align:center; margin-top:40px;">No hay transcripción disponible.</p>';
             }

             if(immSeekBar) {
                 immSeekBar.oninput = () => {
                     audio.currentTime = parseFloat(immSeekBar.value);
                 };
             }

             // Hook into existing audio events to update Immersive UI
             const originalTimeUpdate = audio.ontimeupdate;
             audio.ontimeupdate = (e) => {
                 if(originalTimeUpdate) originalTimeUpdate.call(audio, e);
                 
                 // Update Immersive Seek
                 if(immSeekBar && document.activeElement !== immSeekBar) {
                     immSeekBar.value = audio.currentTime.toString();
                 }
                 
                 
                 // Update Lyrics Active Line
                 if (lyricLines.length > 0 && lyricsWrapper && !lyricsWrapper.classList.contains('hidden')) {
                     const ct = audio.currentTime;
                     let activeIdx = -1;
                     
                     for(let i=0; i < lyricLines.length - 1; i++) {
                         if(ct >= lyricLines[i].time && ct < lyricLines[i+1].time) {
                             activeIdx = i;
                             break;
                         }
                     }
                     
                     if (activeIdx !== -1) {
                         // clear previous active
                         // Note: we target the container specifically
                         if (!lyricsContainer) return; 
                         const currentActive = lyricsContainer.querySelector('.active');
                         if(currentActive && currentActive !== lyricLines[activeIdx].el) {
                             currentActive.classList.remove('active');
                         }
                         
                         if (!lyricLines[activeIdx].el.classList.contains('active')) {
                             lyricLines[activeIdx].el.classList.add('active');
                             
                             // Scroll to view
                             lyricLines[activeIdx].el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                         }
                     }
                 }

                 if(immCurrentTime) {
                     const m = Math.floor(audio.currentTime / 60);
                     const s = Math.floor(audio.currentTime % 60);
                     immCurrentTime.innerText = `${m}:${s < 10 ? '0'+s : s}`;
                 }

                 // Emit Global Time Update
                 document.dispatchEvent(new CustomEvent('veredillas:audio-timeupdate', {
                     detail: { currentTime: audio.currentTime }
                 }));
             };

             const originalLoaded = audio.onloadedmetadata;
             audio.onloadedmetadata = (e) => {
                 if(originalLoaded) originalLoaded.call(audio, e);
                 if(immSeekBar) immSeekBar.max = audio.duration.toString();
                 if(immDuration) {
                     const m = Math.floor(audio.duration / 60);
                     const s = Math.floor(audio.duration % 60);
                     immDuration.innerText = `${m}:${s < 10 ? '0'+s : s}`;
                 }
             };
             
             const originalPlay = audio.onplay;
             audio.onplay = (e) => {
                 if(originalPlay) originalPlay.call(audio, e);
                 if(immIconPlay) immIconPlay.classList.add('hidden');
                 if(immIconPause) immIconPause.classList.remove('hidden');
             };
             
             const originalPause = audio.onpause;
             audio.onpause = (e) => {
                 if(originalPause) originalPause.call(audio, e);
                 if(immIconPlay) immIconPlay.classList.remove('hidden');
                 if(immIconPause) immIconPause.classList.add('hidden');
             };

        };

        // Function to update position and metadata
        const updatePlayerState = () => {
            const player = document.getElementById('mini-player');
            const placeholder = document.getElementById('episode-player-placeholder');
            const container = document.getElementById('player-placeholder');
            const immersiveOverlay = document.getElementById('immersive-player');
            
            // Elements to update in Immersive
            const immTitle = document.getElementById('immersive-title');
            const immAuthor = document.getElementById('immersive-author');
            const immCover = document.getElementById('immersive-cover') as HTMLImageElement;

            if (!player || !container) return;

            if (placeholder) {
                // INLINE MODE CANDIDATE
                const spotifyUrl = placeholder.getAttribute('data-spotify-url');
                const audioUrl = placeholder.getAttribute('data-audio-url');
                const url = spotifyUrl || audioUrl;
                const title = placeholder.getAttribute('data-title');
                const image = placeholder.getAttribute('data-image');
                const author = placeholder.getAttribute('data-author');

                // Update Meta Global
                if (title) window.playerMeta = { title, image: image || '/logo.png', author: author || 'Veredillas FM' };

                // CHECK CONFLICT
                if (window.playerCurrentUrl && url && window.playerCurrentUrl !== url) {
                    // CONFLICT: Show Floating Player
                    if (container.hasChildNodes()) {
                        player.classList.remove('inline', 'hidden');
                        player.classList.add('floating', 'visible');
                        
                        // Setup Floating Styles
                        player.style.position = 'fixed';
                        player.style.top = 'auto';
                        player.style.bottom = '0';
                        player.style.left = '0';
                        player.style.width = '100%';
                        player.style.height = 'auto';
                        
                        const closeBtn = document.getElementById('close-player');
                        if(closeBtn) closeBtn.style.display = 'flex';
                        
                        document.body.style.paddingBottom = '100px';
                        
                        // Populate Immersive if needed
                        if (immTitle && window.playerMeta) {
                            immTitle.innerText = window.playerMeta.title;
                            if (immAuthor) immAuthor.innerText = window.playerMeta.author;
                            immCover.src = window.playerMeta.image;
                            updateAmbientTheme(window.playerMeta.image);
                        }
                    }

                    // Render Prompt in Placeholder
                    if (!placeholder.hasAttribute('data-rendered-prompt')) {
                         placeholder.setAttribute('data-rendered-prompt', 'true');
                         placeholder.innerHTML = `
                            <div class="conflict-wrapper" style="width:100%; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:12px; background: rgba(255,255,255,0.03); border-radius:12px; border: 1px dashed rgba(255,255,255,0.1);">
                                <p style="margin:0; color: #a1a1aa; font-size: 0.95rem; font-weight: 500;">Estás escuchando otro episodio</p>
                                <button id="force-play-btn" style="cursor: pointer; background: white; color: black; border: none; padding: 8px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;">
                                    Reproducir este en su lugar
                                </button>
                            </div>
                        `;
                        
                        const btn = placeholder.querySelector('#force-play-btn');
                        if(btn) {
                            btn.addEventListener('click', () => {
                                window.playerCurrentUrl = null; 
                                container.innerHTML = '';
                                updatePlayerState();
                            });
                        }
                    }
                    return; 
                }
                
                // NO CONFLICT -> Inline Logic
                if (url && (window.playerCurrentUrl !== url)) {
                    window.playerCurrentUrl = url;
                    if(title) window.playerMeta = { title, image: image || '/logo.png', author: author || 'Veredillas FM' };
                    
                    // Update Ambient
                    if (image) updateAmbientTheme(image);
                    
                    if (spotifyUrl) {
                        // Inject Iframe
                        let finalUrl = url;
                        try {
                             const urlObj = new URL(url);
                             if (!urlObj.pathname.includes('/embed/')) {
                                  const segments = urlObj.pathname.split('/').filter(Boolean);
                                  if (segments[0] !== 'embed') finalUrl = `${urlObj.origin}/embed${urlObj.pathname}`;
                             }
                        } catch(e) {}
                        
                        container.innerHTML = `
                            <iframe 
                            id="spotify-iframe"
                            style="border-radius:12px" 
                            src="${finalUrl}?autoplay=0" 
                            width="100%" 
                            height="100%" 
                            frameBorder="0"
                            scrolling="no"
                            allowfullscreen="" 
                            allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
                            loading="lazy">
                        </iframe>
                        `;
                    } else if (audioUrl) {
                        const transcriptionStr = placeholder.getAttribute('data-transcription');
                        const trans = transcriptionStr ? JSON.parse(transcriptionStr) : null;
                        setupCustomPlayer(container, audioUrl, title || 'Episodio', image || '/logo.png', author || 'Veredillas FM', trans);
                    }
                }

                // Inline CSS
                const rect = placeholder.getBoundingClientRect();
                const scrollX = window.scrollX || window.pageXOffset;
                const scrollY = window.scrollY || window.pageYOffset;

                player.classList.remove('floating', 'hidden');
                player.classList.add('inline', 'visible');

                player.style.position = 'absolute';
                player.style.top = `${rect.top + scrollY}px`;
                player.style.left = `${rect.left + scrollX}px`;
                player.style.width = `${rect.width}px`;
                player.style.height = `${rect.height}px`;
                
                // Hide controls in inline
                const ctrls = player.querySelector('.mini-controls') as HTMLElement;
                if(ctrls) ctrls.style.display = 'none';

                document.body.style.paddingBottom = '0';

            } else {
                // FLOATING MODE (Navigating other pages)
                if (container.hasChildNodes()) {
                    player.classList.remove('inline', 'hidden');
                    player.classList.add('floating', 'visible');

                    player.style.position = 'fixed';
                    player.style.top = 'auto';
                    player.style.bottom = '0';
                    player.style.left = '0';
                    player.style.width = '100%';
                    player.style.height = 'auto';

                    const ctrls = player.querySelector('.mini-controls') as HTMLElement;
                    if(ctrls) ctrls.style.display = 'flex';

                    document.body.style.paddingBottom = '100px';

                    // Update Immersive Data if available
                    if (window.playerMeta && immTitle) {
                         immTitle.innerText = window.playerMeta.title;
                         if (immAuthor) immAuthor.innerText = window.playerMeta.author;
                         immCover.src = window.playerMeta.image;
                         updateAmbientTheme(window.playerMeta.image);
                    }
                } else {
                    player.classList.add('hidden');
                    player.classList.remove('visible');
                    document.body.style.paddingBottom = '0';
                }
            }
        };

        // Listeners

        window.addEventListener('resize', updatePlayerState);
        
        // Custom Play Event
        document.addEventListener('play-episode', ((e: Event) => {
             const customEvent = e as CustomEvent;
             const { url, title, image, author } = customEvent.detail;
             
             const container = document.getElementById('player-placeholder');
             
             if (container) {
                 window.playerCurrentUrl = url;
                 if (title) window.playerMeta = { title, image, author };
                 
                 // Reuse insertion logic
                 // ... simplified for brevity, assume updatePlayerState handles if we set the placeholder attrs conceptually or just direct
                 // Since we don't have a placeholder on non-ep pages, we must manually inject into floating
                 // But wait, play-episode usually comes from clicking something.
                 // If we are on a listing page, there is no placeholder.
                 
                 // Direct Inject
                 if (url.includes('spotify.com')) {
                     let finalUrl = url;
                     try {
                         const urlObj = new URL(url);
                         if (!urlObj.pathname.includes('/embed/')) {
                              const segments = urlObj.pathname.split('/').filter(Boolean);
                              if (segments[0] !== 'embed') finalUrl = `${urlObj.origin}/embed${urlObj.pathname}`;
                         }
                     } catch(e) {}

                     container.innerHTML = `
                         <iframe 
                             id="spotify-iframe"
                             style="border-radius:12px" 
                             src="${finalUrl}?autoplay=1" 
                             width="100%" 
                             height="100%" 
                             frameBorder="0" 
                             scrolling="no"
                             allowfullscreen="" 
                             allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" 
                             loading="lazy">
                         </iframe>
                     `;
                 } else {
                     setupCustomPlayer(container, url, title || 'Episodio', image || '/logo.png', author || 'Veredillas FM');
                 }
                  
                  if(image) updateAmbientTheme(image);
                  updatePlayerState();
             }
        }));

        // Close logic
         document.addEventListener('click', (e: Event) => {
            const target = e.target as HTMLElement;
            if (target && target.closest('#close-player')) {
                const player = document.getElementById('mini-player');
                const container = document.getElementById('player-placeholder');
                if (player) {
                    player.classList.remove('visible');
                    document.body.style.paddingBottom = '0';
                    setTimeout(() => {
                        player.classList.add('hidden');
                        if (container) container.innerHTML = '';
                        window.playerCurrentUrl = null;
                        window.playerMeta = null;
                        // Close immersive if open
                        document.getElementById('immersive-player')?.classList.add('hidden');
                    }, 300);
                }
            }
            
            // Expand
            if (target && target.closest('#expand-player')) {
                const immersive = document.getElementById('immersive-player');
                if (immersive) {
                if (immersive) {
                    immersive.classList.remove('hidden');
                    // Visualizer is handled by setupCustomPlayer loop
                }
                }
            }

            // Collapse
            if (target && target.closest('#collapse-player')) {
                 const immersive = document.getElementById('immersive-player');
                 if (immersive) immersive.classList.add('hidden');
            }


        });

    
    // Auto-run setup (MPA mode)
    document.addEventListener('DOMContentLoaded', updatePlayerState);
</script>
