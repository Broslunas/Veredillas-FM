---
import Layout from '../layouts/Layout.astro';
import { getCollection } from 'astro:content';

export const prerender = false;

const allEpisodes = await getCollection('episodios');

function getVideoId(url: string): string | null {
  const patterns = [
    /youtube\.com\/shorts\/([^?&]+)/,
    /(?:youtube\.com\/watch\?v=|youtube\.com\/watch\?.+&v=)([^&]+)/,
    /youtu\.be\/([^?&]+)/,
    /youtube\.com\/embed\/([^?&]+)/,
  ];
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  return null;
}

// Extract all clips and shuffle them for a "feed" feel
let clips = allEpisodes.flatMap(episode => {
  return (episode.data.clips || []).map(clip => ({
    ...clip,
    videoId: getVideoId(clip.url),
    episodeTitle: episode.data.title,
    episodeSlug: episode.slug,
    episodeImage: episode.data.image
  }));
}).sort(() => Math.random() - 0.5); // Simple shuffle

// Check for watch param and move to start
const watchId = Astro.url.searchParams.get('watch');
if (watchId) {
    const index = clips.findIndex(c => c.videoId === watchId);
    if (index > -1) {
        const [selectedClip] = clips.splice(index, 1);
        clips.unshift(selectedClip);
    }
}
---

<Layout title="Clips" description="Los mejores momentos de Veredillas FM en formato corto." showFooter={false}>
  <div class="clips-container" id="clips-container">
    {clips.length > 0 ? (
      clips.map((clip, index) => {
        const videoId = clip.videoId;
        if (!videoId) return null;
        
        return (
        <div class="clip-section" id={`clip-section-${index}`}>
          <div class="video-wrapper">
             <div id={`player-${index}`} class="youtube-player" data-video-id={videoId}></div>
             <!-- Interaction layer for custom play/pause -->
             <div class="interaction-layer" data-target={`player-${index}`}></div>
          </div>
          
          <div class="clip-overlay">
            <div class="clip-info">
                <h2 class="clip-title">{clip.title}</h2>
                <a href={`/ep/${clip.episodeSlug}`} class="episode-link">
                    <span class="episode-icon">üéôÔ∏è</span>
                    <span class="episode-name">{clip.episodeTitle}</span>
                </a>
            </div>
            
            <div class="clip-actions">
                <button class="action-btn like-btn" aria-label="Me gusta" data-clip-id={videoId} onclick="handleLikeClip(this)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="heart-icon"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                </button>
                <button class="action-btn share-btn" aria-label="Compartir" data-clip-id={videoId} onclick="handleShareClip(this)">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>
                </button>
                <a href={`/ep/${clip.episodeSlug}`} class="action-btn" aria-label="Ver episodio completo">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h13M12 5l7 7-7 7"/></svg>
                </a>
            </div>
            <div class="scroll-indicator">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 13l5 5 5-5M7 6l5 5 5-5"/></svg>
            </div>
          </div>
        </div>
      )})
    ) : (
      <div class="no-clips">
        <p>No hay clips disponibles por el momento.</p>
        <a href="/ep" class="back-btn">Ver episodios</a>
      </div>
    )}
  </div>
</Layout>

<style>
  /* Global reset for this page */
  :global(body) {
      overflow: hidden; /* Prevent body scroll, handle in main */
      background-color: #000;
  }

  :global(main) {
    padding-top: 0 !important;
    height: 100vh;
    height: 100dvh;
    overflow-y: scroll;
    scroll-snap-type: y mandatory;
    scrollbar-width: none; /* Firefox */
  }
  
  :global(main)::-webkit-scrollbar {
    display: none; /* Chrome/Safari */
  }

  /* Container */
  .clips-container {
    width: 100%;
    height: 100%;
  }

  /* Individual Clip Section */
  .clip-section {
    position: relative;
    width: 100%;
    height: 100vh;
    height: 100dvh;
    scroll-snap-align: start;
    scroll-snap-stop: always;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #000;
    overflow: hidden;
  }

  /* Video wrapper */
  .video-wrapper {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  .youtube-player {
    width: 100%;
    height: 100%;
    max-width: 500px; /* Limit width on desktop for vertical video feel */
    aspect-ratio: 9/16;
    pointer-events: none; /* Disable native interaction mainly, but clicks might pass */
  }

  /* Interaction Layer ensures we capture taps for play/pause and block YouTube controls */
  .interaction-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
      cursor: pointer;
      /* Ensure taps work on mobile */
      -webkit-tap-highlight-color: transparent;
  }

  @media (min-width: 768px) {
      .youtube-player {
          height: 90vh; /* Give some breathing room on desktop */
          border-radius: 20px;
          overflow: hidden;
      }
      
      /* Match interaction layer to player size on desktop */
      .video-wrapper {
          width: auto;
      }
      .youtube-player, .interaction-layer {
          width: auto;
          aspect-ratio: 9/16;
      }
  }

  /* Overlay UI */
  .clip-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100%;
    padding: 2rem 1.5rem 6rem; /* Extra padding at bottom for mobile nav bars */
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.2) 30%, transparent 100%);
    pointer-events: none; /* Let clicks pass through */
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    z-index: 10;
  }

  .clip-info {
    position: absolute;
    left: 1.5rem;
    bottom: 6rem;
    max-width: 75%;
    pointer-events: auto;
    z-index: 20;
  }

  .clip-title {
    color: white;
    font-size: 1.1rem;
    font-weight: 700;
    margin-bottom: 0.75rem;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .episode-link {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    color: rgba(255, 255, 255, 0.9);
    text-decoration: none;
    font-size: 0.85rem;
    background: rgba(0, 0, 0, 0.5);
    padding: 0.4rem 0.8rem;
    border-radius: 99px;
    backdrop-filter: blur(8px);
    transition: background 0.2s;
    border: 1px solid rgba(255,255,255,0.1);
  }

  .episode-link:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  .clip-actions {
    position: absolute;
    right: 1rem;
    bottom: 6rem;
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
    pointer-events: auto;
    z-index: 20;
    align-items: center;
  }

  .action-btn {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: rgba(30, 30, 30, 0.5);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    cursor: pointer;
    transition: all 0.2s;
  }

  .action-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.1);
  }

  .action-btn.liked {
      background: rgba(255, 255, 255, 1);
      color: #ef4444; /* Red color */
      border-color: #ef4444;
  }
  
  .action-btn.liked svg {
      fill: #ef4444;
  }
  
  .scroll-indicator {
      position: absolute;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.5);
      animation: bounce 2s infinite;
      z-index: 5;
  }
  
  @keyframes bounce {
      0%, 20%, 50%, 80%, 100% {transform: translateX(-50%) translateY(0);}
      40% {transform: translateX(-50%) translateY(-10px);}
      60% {transform: translateX(-50%) translateY(-5px);}
  }

  /* No clips state */
  .no-clips {
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: rgba(255,255,255,0.7);
    gap: 1rem;
  }
  
  .back-btn {
      padding: 0.75rem 1.5rem;
      background: var(--color-primary, #8b5cf6);
      color: white;
      text-decoration: none;
      border-radius: 99px;
      font-weight: 600;
  }

  /* Desktop adjustments */
  @media (min-width: 768px) {
    .clip-overlay {
        justify-content: center;
        align-items: center;
        pointer-events: none;
        background: transparent;
    }
    
    .clip-info {
        position: absolute;
        bottom: 2rem;
        right: 50%;
        margin-right: 270px;
        left: auto;
        transform: none;
        width: 300px;
        text-align: right;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
    }
    
    .clip-actions {
        position: absolute;
        bottom: 2rem;
        left: 50%;
        margin-left: 270px;
        right: auto;
        transform: none;
        align-items: flex-start;
    }

    .scroll-indicator {
        display: none;
    }
  }
</style>

<script is:inline>
    // Use an IIFE or just global scope carefully. 
    // Since Astro viewtransitions re-runs scripts, we need to be careful about redeclaring variables.
    // The previous implementation had 'let players' at top level which is fine for module scope, 
    // BUT if the script tag is re-injected, it re-runs.
    
    // We will attach state to window to survive re-runs and avoid "redeclaration" errors if this were a classic script,
    // though as a module it should be fine. However, let's be extremely robust.

    (function() {
        const WIN = window;
        
        // Initialize global state container if not exists
        if (!WIN._clipsState) {
            WIN._clipsState = {
                players: {},
                playbackObserver: null,
                loadingObserver: null,
                urlObserver: null,
                queue: [],
                apiReady: false,
                stateCache: new Map()
            };
        }

        const state = WIN._clipsState;

        // --- YOUTUBE API SETUP ---
        if (!WIN.YT) {
            if (!document.getElementById('yt-api-script')) {
                const tag = document.createElement('script');
                tag.id = 'yt-api-script';
                tag.src = "https://www.youtube.com/iframe_api";
                const firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag?.parentNode?.insertBefore(tag, firstScriptTag);
            }
            
            WIN.onYouTubeIframeAPIReady = function() {
                state.apiReady = true;
                processQueue();
            };
        } else {
            state.apiReady = true;
            // Process queue next tick to ensure DOM is ready if valid
            setTimeout(processQueue, 0);
        }

        function processQueue() {
            while (state.queue.length > 0) {
                const id = state.queue.shift();
                if (id) createPlayer(id);
            }
        }

        function createPlayer(id) {
            // Check global YT object
            if (!WIN.YT || !WIN.YT.Player) {
                if (!state.queue.includes(id)) state.queue.push(id);
                return;
            }

            if (state.players[id]) return; // Already created

            const element = document.getElementById(id);
            if (!element) return;

            const videoId = element.getAttribute('data-video-id');
            if (!videoId) return;

            // Create player
            state.players[id] = new WIN.YT.Player(id, {
                height: '100%',
                width: '100%',
                videoId: videoId,
                playerVars: {
                    'playsinline': 1,
                    'controls': 0,
                    'rel': 0,
                    'modestbranding': 1,
                    'showinfo': 0, 
                    'iv_load_policy': 3, 
                    'fs': 0,
                    'disablekb': 1,
                    'origin': WIN.location.origin
                },
                events: {
                    'onStateChange': (e) => onPlayerStateChange(id, e)
                }
            });
        }

        function onPlayerStateChange(id, event) {
            state.stateCache.set(id, event.data);
            if (event.data === WIN.YT.PlayerState.ENDED) {
                event.target.playVideo();
            }
        }

        function togglePlay(id) {
            const player = state.players[id];
            if (player && typeof player.getPlayerState === 'function') {
                const playerState = player.getPlayerState();
                if (playerState === WIN.YT.PlayerState.PLAYING) {
                    player.pauseVideo();
                } else {
                    player.playVideo();
                    player.unMute();
                }
            }
        }

        // --- OBSERVERS ---
        function initObservers() {
            // Loading
            state.loadingObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const playerDiv = entry.target.querySelector('.youtube-player');
                        if (playerDiv) createPlayer(playerDiv.id);
                    }
                });
            }, { root: null, rootMargin: '50% 0px 50% 0px' });

            // Playback
            state.playbackObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const playerDiv = entry.target.querySelector('.youtube-player');
                    if (!playerDiv) return;
                    const id = playerDiv.id;
                    const player = state.players[id];
                    
                    if (entry.isIntersecting) {
                        if (player && typeof player.playVideo === 'function') player.playVideo();
                    } else {
                        if (player && typeof player.pauseVideo === 'function') player.pauseVideo();
                    }
                });
            }, { root: null, rootMargin: '0px', threshold: 0.6 });

            document.querySelectorAll('.clip-section').forEach(section => {
                state.loadingObserver.observe(section);
                state.playbackObserver.observe(section);
            });

            // Interaction Layer Clicks
            document.querySelectorAll('.interaction-layer').forEach((layer) => {
                // Remove old listeners? The elements are new on page load, so simple add is fine.
                layer.onclick = (e) => {
                    const targetId = e.currentTarget.getAttribute('data-target');
                    if (targetId) togglePlay(targetId);
                };
            });
        }

        function checkWatchParam() {
            const urlParams = new URLSearchParams(WIN.location.search);
            const watchId = urlParams.get('watch');
            if (!watchId) {
                const firstPlayer = document.querySelector('.youtube-player');
                if (firstPlayer) {
                    const firstId = firstPlayer.getAttribute('data-video-id');
                    if (firstId) {
                        const url = new URL(WIN.location.href);
                        url.searchParams.set('watch', firstId);
                        WIN.history.replaceState({}, '', url);
                    }
                }
            }
        }

        function initUrlObserver() {
            if (state.urlObserver) state.urlObserver.disconnect();
            
            state.urlObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const playerDiv = entry.target.querySelector('.youtube-player');
                        if (playerDiv) {
                            const videoId = playerDiv.getAttribute('data-video-id');
                            if (videoId) {
                                const url = new URL(WIN.location.href);
                                if (url.searchParams.get('watch') !== videoId) {
                                    url.searchParams.set('watch', videoId);
                                    WIN.history.replaceState({}, '', url);
                                }
                            }
                        }
                    }
                });
            }, { threshold: 0.7 });

            document.querySelectorAll('.clip-section').forEach(section => {
                state.urlObserver.observe(section);
            });
        }

        // --- GLOBAL ACTIONS (for onclick) ---
        WIN.handleLikeClip = async function(btn) {
            if (WIN.event) {
                WIN.event.stopPropagation();
                WIN.event.preventDefault();
            }

            const clipId = btn.getAttribute('data-clip-id');
            if (!clipId) return;

            const isLiked = btn.classList.contains('liked');

            // Optimistic
            if (isLiked) {
                btn.classList.remove('liked');
                btn.querySelector('svg')?.setAttribute('fill', 'none');
            } else {
                btn.classList.add('liked');
                btn.querySelector('svg')?.setAttribute('fill', '#ef4444');
                btn.animate([{transform:'scale(1)'}, {transform:'scale(1.3)'}, {transform:'scale(1)'}], {duration:200});
            }

            try {
                const res = await fetch('/api/clips/like', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({clipId})
                });
                if (res.status === 401) {
                    WIN.location.href = '/login';
                    return;
                }
            } catch(e) {
                console.error(e);
                // Revert
                 if (isLiked) {
                    btn.classList.add('liked');
                    btn.querySelector('svg')?.setAttribute('fill', '#ef4444');
                } else {
                    btn.classList.remove('liked');
                    btn.querySelector('svg')?.setAttribute('fill', 'none');
                }
            }
        };

        WIN.handleShareClip = function(btn) {
            if (WIN.event) {
                WIN.event.stopPropagation();
                WIN.event.preventDefault();
            }
            const clipId = btn.getAttribute('data-clip-id');
            const url = new URL(WIN.location.href);
            if (clipId) url.searchParams.set('watch', clipId);
            
            navigator.clipboard.writeText(url.toString()).then(() => {
                const original = btn.innerHTML;
                btn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
                setTimeout(() => { btn.innerHTML = original; }, 2000);
            });
        };

        async function loadLikes() {
            try {
                const res = await fetch('/api/clips/liked');
                if (res.ok) {
                    const data = await res.json();
                    const liked = data.likedClips || [];
                    document.querySelectorAll('.like-btn').forEach(btn => {
                        const cid = btn.getAttribute('data-clip-id');
                        if (cid && liked.includes(cid)) {
                            btn.classList.add('liked');
                            btn.querySelector('svg')?.setAttribute('fill', '#ef4444');
                        }
                    });
                }
            } catch(e) { console.error(e); }
        }

        // --- INIT ---
        function initPage() {
            // Only run on clips page
            if (!document.querySelector('.clips-container')) return;
            
            // Cleanup
            if (state.loadingObserver) state.loadingObserver.disconnect();
            if (state.playbackObserver) state.playbackObserver.disconnect();
            if (state.urlObserver) state.urlObserver.disconnect();
            
            // Destroy old players
            Object.values(state.players).forEach(p => { 
                if(p && typeof p.destroy === 'function') { try { p.destroy(); } catch(e) {} }
            });
            state.players = {};

            // Start
            initObservers();
            loadLikes();
            checkWatchParam();
            initUrlObserver();
        }

        // Register astro:page-load only once (guard against duplicate registration on script re-run)
        if (!WIN._clipsPageLoadRegistered) {
            WIN._clipsPageLoadRegistered = true;
            document.addEventListener('astro:page-load', initPage);
        }
        
        // CRITICAL: Also call initPage() immediately!
        // With is:inline, the astro:page-load event may have already fired before this script runs.
        // So we must initialize now.
        initPage();
        
    })();
</script>
